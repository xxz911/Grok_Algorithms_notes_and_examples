# Задача с составлением расписания
# Есть учебный класс, в котором надо провести как можно больше уроков, у нас есть список уроков
# Рисование 9:00 - 10:00
# Английский 9:30 - 10:30
# Математика 10:00 - 11:00
# Информатика 10:30 - 11:30
# Музыка 11:00 - 12:00
# Провести все уроки НЕПОЛУЧИТСЯ, так как некоторые из них перекрываются по времени

# Алгоритм выглядит следующим образом
# 1. Выбрать урок, который завершается раньше всех. Это первый урок, который будет в классе
# 2. Затем выбирается урок, начинающийся после завершения первого урока и снова следует выбрать урок,
# который завершается раньше всех остальных. Он станет вторым уроком

# Раньше всех заканчивает урок по Рисованию (9:00 - 10:00)
# После Рисования ближайшим уроком будет Математика(10:00 - 11:00)
# После Математики ближайший урок будет Музыка(11:00 - 12:00)

# Жадные алгоритмы просты, В нашем примере на каждом этапе выбирается оптимальный вариант,
# в технической терминологии на каждом шаге выбирается локально-оптимальное решения
# Жадная стратегия не дает оптимального решения, при этом результат не так уж и далек от оптимума.
# Иногда достаточно алгоритма, способного решить задачу достаточно хорошо


# Задача о покрытии множества
# Мы открываем собственную авторскую программу на радио и хотим чтобы нас слушали во всех 50-ти штатах,
# каждая станция стоит денег, поэтому их количество надо свести к минимуму
# Каждая станция покрывает определенное кол-во штатов
# Алгоритм для поиска набора станций, который покрывает ВСЕ 50 штатов
# 1. Составить список всех возможных подмножеств станций, так называемое СТЕПЕННОЕ ПОДМНОЖЕСТВО.
# В нем содержаться 2^n возможных подмножеств
# 2. Из этого списка выбирается подмножество с наименьшим набором станций, покрывающих ВСЕ 50 штатов
# ПРОБЛЕМА В ТОМ, что НЕСУЩЕСТВУЕТ алгоритма, который будет вычислять подмножества с ПРИЕМЛЕМОЙ СКОРОСТЬЮ

# И тут нам помогут ПРИБЛИЖЕННЫЕ АЛГОРИТМЫ(ЖАДНЫЕ АЛГОРИТМЫ)
# Этот алгоритм является ПРИБЛИЖЕННЫМ. Когда вычисление точного решения занимает слишком много времени, применяется ОН
# Эффективность ПРИБЛИЖЕННОГО АЛГОРИТМЫ оценивается по(быстроте и близости полученного решения к оптимальному)
# 1. Выбрать станцию, покрывающую наибольшее кол-во штатов, еще не входящих в покрытие.
# Если станция будет покрывать некоторые штаты, которые уже входят в покрытие, это нормально
# 2. Повторять, пока остаются штаты, не входящие в покрытие

# Реализация в коде(в этом примере будет меньше станций)
# Напоминаю, что во множестве не может быть дубликатов

# Составляем список штатов(преобразуется во множество)
states_needed = {'mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'}
# Создаем список(словарь) станций, из которого будет выбираться покрытие
stations = {}
# Ключи - название станций, значения - штаты
stations['kone'] = {"id", "nv", "ut"}
stations['ktwo'] = {"wa", "id", "mt"}
stations['kthree'] = {"or", "nv", "ca"}
stations['kfour'] = {"nv", "ut"}
stations['kfive'] = {"ca", "az"}
# Набор для хранения итоговых станций
final_stations = set()

# Пока есть нужные нам штаты
while states_needed:
    # Станция, которая включает больше всего штатов, не входящих в текущее покрытие
    best_station = None
    # Набор станций, которые входят в текущее покрытие
    states_covered = set()
    # Перебираем все станции и находим среди них лучшую
    for station, states_for_station in stations.items():
        # Используем пересечение(общие для обоих множеств) множеств
        # В результате covered содержит штаты, не входящие в покрытие, которые покрываются текущей станцией
        covered = states_needed & states_for_station
        # Проверяем покрывает ли эта станция больше штатов, чем текущая станция best_station, если да
        if len(covered) > len(states_covered):
            # Обновляем лучшую станцию
            best_station = station
            # Добавляем штаты, из лучшей станции в покрываемые
            states_covered = covered
    # Убираем из нужных нам станций уже покрытые
    states_needed -= states_covered
    # Добавляем станцию в наш итоговый массив
    final_stations.add(best_station)
# Получаем массив станций
print(final_stations)


# NP-полные задачи
# (пример: задача о Коммивояже(кратчайший путь с заходом во все города), задачи с полным покрытием(наша задача с радиостанциями)
# У NP-полных задач не имеется известных быстрых алгоритмов
# Жадные алгоритмы легко реализуются и быстро выполняются, поэтому из них получаются хорошие приближенные алгоритмы
# Если есть NP-полная задача, то лучший выбор это воспользоваться жадным приближенным алгоритмом

