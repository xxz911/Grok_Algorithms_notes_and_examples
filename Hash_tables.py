# Хеш-функция - функция, которая получает строку(любая последовательность байтов) и возвращает число
# Требования к хеш-функция:
# 1. Она должна быть последовательной(неизменно возвращали один и тот же результат для одинаковых входных данных)
# 2. Разным словам должны соответствовать разные числа(в идеале каждое слово должно иметь свое число)

# Если связать в едино хеш-функцию и массив, то получаем ХЕШ-ТАБЛИЦУ
# Еще их называют: ассоциативные массивы, словари, отображения, хеш-карты, хеши
# В Python хеш-таблицей является СЛОВАРЬ(dict)
# Хеш-таблица состоит из ключа и значения(она их связывает)

# Примеры использования хеш-таблиц(О(1)постоянная)
# 1. Хеш-таблица для поиска(пример, телефонная книга)
# Хеш таблицы отлично работают, если нам надо:
# - создать связь, отображающую один объект на другой
# - найти значение в списке

# Создаем телефонную книгу
phone_book = dict()
# Добавляем контакты и номера
phone_book['Alex'] = 89992345421
phone_book['Tom'] = 45344343434
# Ищем номер контакта
print(phone_book['Alex'])
# Кстате, имя веб сайта преобразуется в IP-адрес с помощью хеш-таблиц, этот процесс называется ПРЕОБРАЗОВАНИЕМ DNS


# 2. Хеш-таблица для исключения дубликатов(пример, журнал голосования)
# Создаем журнал
voted = {}
# Проверяем есть ли человек в журнале
def check_voter(name):
    # Если человек есть в журнале
    if voted.get(name):
        print("Ты уже голосовал!")
    # Если человека нет в журнале
    else:
        # Добавляем человека в журнал
        voted[name] = True
        print("Можете голосовать")

# Проверяем функцию(Один человек два раза голосует)
check_voter("Pit")
check_voter("Pit")


# 3. Хеш-таблица как кеш(пример, кеш в веб-сайте)
# Кешированные данные на сервере хранятся в хеше
# Хеши хорошо подходят для решения следющих задач:
# - моделирование отношений между объектами
# - устранение дубликатов
# - кеширование/запоминание данных вместо выполнения работы на сервере

# Создаем хеш
cache = {}
# Проверяем есть ли url в кеше
def get_page(url):
    # Если url есть в кеше, возвращаем кешированные данные
    if cache.get(url):
        return cache[url]
    # Если url нет в кеше, то делаем запрос на сервер и сохраняем url в кеш
    else:
        data = get_data_from_server(url)
        cache[url] = data
        return data


# Коллизия
# Под ней понимается ситуация, когда хеш-функция пытается добавить элемент в занятую ячейку
# (например хеш-функция заполняет ячейки по алфавиту, сначала апельсин, потом банан, потом ананс)
# Существует много стратегий обработки коллизий, простейшая из которых выглядит так: если несколько ключей
# отображаются на один элемент, то в этом элементе создается связанный список,
# НО в нашем примере если все элементы будут начинаться на 'а', то массив будет пуст, кроме первой ячейки
# ИЗ-ЗА этого следуют ДВА ВАЖНЫХ УРОКА!
# 1. Выбор хещ-функции важен(в идеале хеш-функция должна распределять ключи равномерно по всему хешу)
# 2. Если связанные списки станут слишком длинными, то работа с хе-функцией сильно замедлится, поэтому нужна ХОРОШАЯ
# хеш-функция

# ВАЖНО, реализовывать хеш-функцию самостоятельно вряд-ли нам придется, так как есть готовые решения во всех языках
# программирования