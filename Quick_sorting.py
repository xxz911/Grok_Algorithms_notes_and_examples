# Стратегия разделяй и властвуй(является скорее подходом к решению задач):
# 1. Определить простейший случай, как базовый
# 2. Придумать, как свести задачу к базовому случаю

# Совет!! когда мы пишем рекурсивную функцию, в которое задействован массив,
# базовым случаем часто оказывается пустой массив или массив из одного элемента

# Пример, нам надо просуммировать все элементы массива [2, 4, 6]
list = [2, 4, 6]

# 1 шаг. Надо определить базовый случай
# (как выглядит самый простой массив, который мы можем получить?)

# Базовый случай, если 0 элементов, то сумма равна 0,
# и если 1 элемент, то сумма равна значению 1 элемента


# 2 шаг. Каждый рекурсивный вызов должен приближать нас к пустому массиву,
# как уменьшить размер задачи?

# Первый вариант:
# sum([2, 4, 6]) сумма равна 12
# Второй вариант:
# 2 + sum([4, 6]) сумма равна 12

# В обоих случаях сумма равна 12,
# НО во втором варианте функции sum() передается меньший массив

# Решение
def summa(list):
    # Базовый случаи
    if list == []:
        return 0
    # Рекурсивный случай
    return list[0] + summa(list[1:])


print(summa(list))


# Рекурсивная функция для количества элементов
def count(list):
    # Базовый случаи
    if list == []:
        return 0
    # Рекурсивный случай
    return 1 + count(list[1:])


print(count(list))


# Рекурсивная функция для поиска наибольшего значения в массиве
def maxx(list):
    # Базовый случаи
    if len(list) == 2:
        return list[0] if list[0] > list[1] else list[1]
    # Рекурсивный случай
    max_in = maxx(list[1:])
    return list[0] if list[0] > max_in else max_in


print(maxx(list))

# Быстрая сортировка O(n log n)
# Работает быстрее сортировки выбором
# Пустые массивы и массивы содержащие всего один элемент являются базовыми случаями,
# их сортировать не надо
# В соответствии со стратегией "Разделяй и властвуй" массив должен разделяться до того момента,
# пока не достигнет базового случая(Алгоритм следующий: сначала в массиве выбирается элемент,
# который называется опорным,
# потом находятся элементы, которые меньше опорного и элементы больше опорного), этот
# процесс называется РАЗДЕЛЕНИЕМ.

# После разделения у нас есть:
# 1. Подмассив всех элементов, меньших опорного
# 2. Опорный элемент
# 3. Подмассив всех элементов, больших опорного
# При этом два подмассива не отсортированы, теперь надо отсортировать их, применив алгоритм
# быстрой сортировки и объединить результаты (левый подмассив - опорный - правый подмассив)
# Этот метод работает при ЛЮБОМ опорном элементе


# Функция быстрой сортировки
def quicksort(array):
    # Базовый случай (массивы с 0 и 1 элементом уже отсортированны)
    if len(array) < 2:
        return array
    # Рекурсивный случай
    else:
        # Опорный элемент
        pivot = array[0]
        # Левый подмассив
        less = [i for i in array[1:] if i < pivot]
        # Правый подмассив
        greater = [i for i in array[1:] if i > pivot]
        # Формаирование отсортированного массива
        return quicksort(less) + [pivot] + quicksort(greater)


list2 = [9, 2, 6, 3, 4]
print(quicksort(list2))