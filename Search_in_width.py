# Предположим, у нас есть задача, найти кратчайший путь по схеме от пункта дома, до магазина
# Задача такого типа называется ЗАДАЧЕЙ ПОИСКА КРАТЧАЙШЕГО ПУТИ
# АЛГОРИТМ для решения задачи поиска кратчайшего пути называется ПОИСКОМ В ШИРИНУ

# Для решения задачи нам пришлось бы выполнить ДВА шага:
# 1. Смоделировать задачу в виде графа
# 2. Решить задачу методом поиска в ширину


# Граф
# граф моделирует набор связей между разными объектами
# Например мы играем с друзьями в покер и нам надо смоделировать кто кому должен
# Каждый граф состоит из УЗЛОВ(имена) и РЕБЕР(=>)
# Узел может быть соединен НАПРЯМУЮ с несколькими другими узлами, такие узлы называются СОСЕДЯМИ
# (в нашем примере это (Алекс и Том) и (Том и Ник), при это (Алекс и Ник) не являются соседями)

# Алекс => Том => Ник

# Если в список графа отсортирован таким образом, что
# (например: задача А зависит от задачи В, то задача А находится на более поздней позиции списка),
# то такая сортировка называется ТОПОЛОГИЧЕСКОЙ
# ПОДКАТЕГОРИЕЙ графа является дерево(пример: Генеалогическое дерево),
# в нем тоже есть узлы и рёбра, и ВСЕ ребра направленны в одну сторону,
# ПРИ ЭТОМ любое дерево является графом, но не каждый граф является деревом


# Поиск в ширину
# Поиск в ширину является алгоритмом поиска, ОДНАКО этот алгоритм работает С ГРАФАМИ
# Он может ответить на вопросы ДВУХ типов:
# 1. Существует ли путь от узла А к узлу Б
# 2. Как выглядит кратчайший путь от узла А к узлу Б


# Наша задача с домом и магазином была вопросом 2-го типа!
# Теперь разберемся с работой алгоритма с вопросом 1-го типа


# Представим, что мы выращиваем манго и ищем продавца, который будет их продавать
# Возможно им станет кто то из наших контактов из VK? Для начала стоит поискать среди друзей
# Сначала надо построить список друзей из поиска
# Теперь надо обратиться к каждому другу и узнать продает ли он манго
# Предположим, что никто из наших друзей их не продает
# Теперь надо искать среди наших друзей наших друзей
# Каждый раз, когда мы проверяем кого-то из друзей наших друзей, мы добавляем ЕГО к себе в список
# В таком случае поиск ведется не только среди наших друзей, но и среди друзей наши друзей
# С таким алгоритмом мы рано или поздно обойдем всю сеть VK, пока не найдем продавца манго
# Такой алгоритм и называется ПОИСКОМ В ШИРИНУ(вопрос 1-го типа)

# Теперь ответим на вопрос 2-го типа(поиск кратчайшего пути) с нашей задачей про манго
# Предположим, что наши друзья являются связями 1-го уровня, а друзья наших друзей 2-го уровня
# Связи 1- уровня предпочтительнее 2-го, связи 2-го предпочтительнее 3-го и т.д.
# Отсюда следует, что поиск по друзям наших друзей(2-й уровень связи) не должен проводится,
# пока мы не проверим ВСЕХ наших друзей(связь 1-го уровня)
# Поиск в ширину распространяется от НАЧАЛЬНОЙ ТОЧКИ
# Связи 1-го уровня добавляются раньше связей 2-го уровня(мы двигаемся вниз по списку и проверяем каждого человека)
# Так мы найдем продавца ближайшего к нам в сети. Поиск в ширину находит не только путь от А до Б, но и кратчайший путь
# ПОЭТОМУ проверять связи надо нужно в прорядке их добавления, для такой оперции существует специальная СТРУКТУРА ДАННЫХ,
# которая называется ОЧЕРЕДЬЮ


# Очереди
# Очереди похожи на обычные очереди из нашей жизни(например очередь в автобус)
# Очереди похожи на стеки(мы не можем обращаться к произвольным элементам очереди)
# вместе этого ПОДДЕРЖИВАЕТСЯ ДВЕ ОПЕРАЦИИ:
# 1. Постановка в очередь
# 2. Извлечение из очереди
# Очередь относится к категории структур данны FIFO:First In, First Out(первым защел, первым вышел)


# Реализация графа программно
# Отношения типа "Вы => Боб" выражаются с помощью структуры данных ХЕШ-Таблица(словарь)
# graph = {}
# graph['you'] = ['Tom', "Bob", "Sam"]
# Результатом выражения graph['you'] являются Ваши соседи, при этом НЕВАЖНО в каком порядке добавлять "ключ-значение",
# так как Хеш-таблицы не упорядоченны

# Виды графов
# У Боба нет соседей, от него нет линии со стрелками, а у Пети есть, такой граф называется НАПРАВЛЕННЫЙ
# (отношения действуют только в одну строну). У Пети есть сосед, у Боба нет
# Петя => Боб

# В этой записи Петя и Боб и Боб и Петя являются соседями, такой граф называется НЕНАПРАВЛЕННЫМ
# Петя == Боб


# Реализация алгоритма
# В Python все начинается с создания очереди, для создания ДВУСТОРОННЕЙ ОЧЕРЕДИ(дека) используется функция deque()
from collections import deque
# Cоздаем граф(словарь)
graph = {}
# Наполняем его отношениями
graph['You'] = ['Tom', 'Bob', 'Sam']
graph['Tom'] = []
graph['Bob'] = ['Tom', 'Sam']
graph['Sam'] = ['Bob', 'Max']
graph['Max'] = ['Bob']


# Функция для определения продавца манго(в примере имя продавца манго "Max")
def person_is_seller(name):
    return name == 'Max'


# Функция для поиска продавца манго
def search_mango_seller(name):
    # Создание новой очереди
    search_queue = deque()
    # Все соседи добавляются в очередь
    search_queue += graph[name]
    # Массив для проверенных людей(чтобы убрать дублирование имен в проверке, и избежать возможного зацикливания)
    searched = []
# Пока очередь не пуста
    while search_queue:
        # Из очереди извлекается первый человек
        person = search_queue.popleft()
        # Если человек еще не проверялся
        if not person in searched:
            # Проверяем, является ли человек продавцом манго
            # Если является продавцом
            if person_is_seller(person):
                print(person, "it`s mango seller!")
                return True
            # Если не является продавцом
            else:
                # Добавляем его соседей в очередь
                search_queue += graph[person]
                # Добавляем его в массив для проверенных людей
                searched.append(person)
    # Если программа дошла до сюда, значит в очереди нет продавца манго
    return print('Mango seller not found')
# Алгоритм будет работать до тех пор, пока:
# 1. Не будет найден продавец манго
# 2. Очередь не опустеет(в этом случае продавца манго нет)

# Проверяем нашу функцию
search_mango_seller('You')



